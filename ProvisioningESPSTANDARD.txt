<<<<<<< HEAD
/*
  PawfeedsStd_Slave.ino - FINAL CLOUD-ENABLED & CONTAINER WEIGHT MONITORING
  - Connects to Wi-Fi.
  - On first connection, calls a Cloud Function to register itself in Firestore.
  - Dispenses food based on a timer (original method).
  - Uses an HX711 load cell to monitor the weight of the main food container.
*/
#include <WiFi.h>
#include <Preferences.h>
#include <WebServer.h>
#include <ESP32Servo.h>
#include <HardwareSerial.h>
#include <HTTPClient.h>
#include "HX711.h"

// =================================================================
// HX711 Weight Sensor Configuration (for Container Monitoring)
// =================================================================
// GPIO pins for the HX711
const int LOADCELL_DOUT_PIN = 25; // DT pin
const int LOADCELL_SCK_PIN = 18;  // SCK pin

HX711 scale;

// IMPORTANT: This calibration factor is unique to your load cell.
// You MUST calibrate your sensor to get accurate readings.
float calibration_factor = -7050.0; // Placeholder value, adjust this!

// =================================================================
// Original Hardware & Network Configuration
// =================================================================
HardwareSerial SerialMaster(2); // RX2: 16, TX2: 17
HardwareSerial SerialFeeder2(1); // RX1: 21, TX1: 22

Servo foodServo1;
Servo foodServo2;
static const int SERVO_PIN_1 = 14;
static const int SERVO_PIN_2 = 15;
static const int SERVO_STOP_ANGLE = 90;
static const int SERVO_RUN_ANGLE = 0;

// --- Restored Time-Based Dispensing Variables ---
static const int MS_PER_GRAM = 77;
static const int OFFSET_MS = -350;
bool isDispensing[2] = {false, false};
unsigned long dispenseStartTime[2] = {0, 0};
unsigned long dispenseDuration[2] = {0, 0};

unsigned long lastFwdAttempt = 0;
const unsigned long FWD_INTERVAL_MS = 5000;

Preferences prefs;
WebServer server(80);
static const char* NVS_NS = "pawfeeds";
static const uint8_t MAX_CONNECT_SECONDS = 30;
// --- IMPORTANT: Paste your Cloud Function URL here ---
const char* cloudFunctionUrl = "https://registerdevice-cy5wm3auoq-df.a.run.app";

String ipToStr(IPAddress ip) {
  return String(ip[0]) + "." + ip[1] + "." + ip[2] + "." + ip[3];
}

void handleStatus() {
  String ip = (WiFi.isConnected()) ? ipToStr(WiFi.localIP()) : "";
  String hostname = WiFi.getHostname() ? String(WiFi.getHostname()) : "";
  
  // Read current container weight from the sensor
  float container_weight = scale.get_units(5); // Get an average of 5 readings
  
  String body = String("{\"mode\":\"sta\",\"connected\":") + (WiFi.isConnected() ? "true" : "false") +
                ",\"ip\":\"" + ip +
                "\",\"hostname\":\"" + hostname + 
                "\",\"container_weight_grams\":" + String(container_weight) + "}";
  server.send(200, "application/json", body);
}

// --- Restored Original Time-Based handleFeed function ---
void handleFeed() {
  if (!server.hasArg("plain")) {
    server.send(400, "application/json", "{\"error\":\"missing_body\"}");
    return;
  }
  String body = server.arg("plain");
  String keyGrams = "\"grams\":";
  int keyIndexGrams = body.indexOf(keyGrams);
  int grams = 0;
  if (keyIndexGrams != -1) {
    int valueIndex = keyIndexGrams + keyGrams.length();
    grams = body.substring(valueIndex).toInt();
  }

  String keyFeeder = "\"feeder\":";
  int keyIndexFeeder = body.indexOf(keyFeeder);
  int feederId = 1;
  if (keyIndexFeeder != -1) {
    int valueIndex = keyIndexFeeder + keyFeeder.length();
    feederId = body.substring(valueIndex).toInt();
  }
  
  int feederIndex = (feederId == 2) ? 1 : 0;
  if (isDispensing[feederIndex]) {
    server.send(409, "application/json", "{\"status\":\"busy\", \"feeder\":" + String(feederId) + "}");
    return;
  }
  
  if (grams <= 0) {
    server.send(400, "application/json", "{\"error\":\"invalid_grams\", \"received_body\":\"" + body + "\"}");
    return;
  }
  
  isDispensing[feederIndex] = true;
  long calculatedDuration = ((long)grams * MS_PER_GRAM) + OFFSET_MS;
  dispenseDuration[feederIndex] = (calculatedDuration > 0) ? calculatedDuration : 0;
  dispenseStartTime[feederIndex] = millis();
  if (feederIndex == 0) {
    foodServo1.write(SERVO_RUN_ANGLE);
  } else {
    foodServo2.write(SERVO_RUN_ANGLE);
  }
  
  Serial.printf("[/feed] Dispensing %d grams from feeder %d for %lu ms\n", grams, feederId, dispenseDuration[feederIndex]);
  server.send(202, "application/json", "{\"status\":\"started\", \"grams\":" + String(grams) + ", \"feeder\":" + String(feederId) + "}");
}


void eraseCreds() {
  prefs.begin(NVS_NS, false);
  prefs.remove("wifi_ssid");
  prefs.remove("wifi_pass");
  prefs.remove("hostname");
  prefs.remove("fwd_complete");
  prefs.remove("uid");
  prefs.remove("registered");
  prefs.end();
  Serial.println("[NVS] Cleared credentials, UID, forwarding flag, and registered flag.");
}

void handleFactoryReset() {
  eraseCreds();
  server.send(200, "application/json", "{\"ok\":true,\"reset\":true}");
  Serial.println("[/factory_reset] Reset + reboot");
  delay(250);
  ESP.restart();
}

void saveCreds(const String& ssid, const String& pass, const String& customName, const String& uid) {
  prefs.begin(NVS_NS, false);
  prefs.putString("wifi_ssid", ssid);
  prefs.putString("wifi_pass", pass);
  String finalHost = "pawfeeds-std-" + customName;
  prefs.putString("hostname", finalHost);
  prefs.putString("uid", uid);
  prefs.putBool("fwd_complete", false);
  prefs.putBool("registered", false);
  prefs.end();
  Serial.println("[NVS] Saved credentials for Standard Feeder. Forwarding/Registered flags set to false.");
  Serial.printf("  -> Hostname: %s\n", finalHost.c_str());
  Serial.printf("  -> UID: %s\n", uid.c_str());
}

void registerDeviceInCloud() {
  prefs.begin(NVS_NS, true);
  bool isRegistered = prefs.getBool("registered", false);
  String uid = prefs.getString("uid", "");
  String hostname = prefs.getString("hostname", "");
  prefs.end();
  if (isRegistered || uid.length() == 0 || hostname.length() == 0) {
    return;
  }

  Serial.println("[Cloud] Device not registered. Attempting to register now...");

  HTTPClient http;
  http.begin(cloudFunctionUrl);
  http.addHeader("Content-Type", "application/json");

  String deviceId = WiFi.macAddress();
  deviceId.replace(":", "");
  String payload = "{\"data\":{\"uid\":\"" + uid + "\",\"deviceId\":\"" + deviceId + "\",\"name\":\"" + hostname + "\"}}";
  int httpCode = http.POST(payload);

  if (httpCode > 0) {
    String response = http.getString();
    Serial.printf("[Cloud] Registration response code: %d\n", httpCode);
    Serial.println("[Cloud] Response: " + response);
    if (httpCode == 200) {
      Serial.println("[Cloud] Registration successful! Setting flag.");
      prefs.begin(NVS_NS, false);
      prefs.putBool("registered", true);
      prefs.end();
    }
  } else {
    Serial.printf("[Cloud] Registration failed, error: %s\n", http.errorToString(httpCode).c_str());
  }
  http.end();
}

bool trySTA() {
  prefs.begin(NVS_NS, true);
  String ssid = prefs.getString("wifi_ssid", "");
  String pass = prefs.getString("wifi_pass", "");
  String host = prefs.getString("hostname", "");
  prefs.end();
  if (ssid.length() == 0) return false;

  Serial.println("[STA] Trying to connect with saved credentials...");
  WiFi.mode(WIFI_STA);
  if (host.length()) WiFi.setHostname(host.c_str());
  WiFi.begin(ssid.c_str(), pass.c_str());
  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && (millis() - t0) < (MAX_CONNECT_SECONDS * 1000UL)) {
    delay(300);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("[STA] Connected. IP=%s Hostname=%s\n", WiFi.localIP().toString().c_str(), WiFi.getHostname() ? WiFi.getHostname() : "(none)");
    registerDeviceInCloud();
    return true;
  }
  Serial.printf("[STA] Failed, status=%d\n", WiFi.status());
  return false;
}

void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\n=== PawfeedsStd SLAVE/FORWARDER Boot (Container Weight Monitoring) ===");

  SerialMaster.begin(9600, SERIAL_8N1, 16, 17);
  SerialFeeder2.begin(9600, SERIAL_8N1, 21, 22);
  Serial.println("[Serial] Initialized Serial1(RX:21,TX:22) and Serial2(RX:16,TX:17).");
  
  // --- HX711 Initialization ---
  Serial.println("[HX711] Initializing scale for container monitoring...");
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
  scale.set_scale(calibration_factor);
  scale.tare(10); // Tare the scale on boot-up. Assumes container is empty at this point.
  Serial.println("[HX711] Scale initialized and tared.");
  Serial.printf("[HX711] Initial container reading: %.2fg\n", scale.get_units(5));

  ESP32PWM::allocateTimer(0);
  foodServo1.setPeriodHertz(50);
  foodServo1.attach(SERVO_PIN_1, 500, 2400);
  foodServo1.write(SERVO_STOP_ANGLE);

  ESP32PWM::allocateTimer(1);
  foodServo2.setPeriodHertz(50);
  foodServo2.attach(SERVO_PIN_2, 500, 2400);
  foodServo2.write(SERVO_STOP_ANGLE);
  Serial.println("[SERVO] Initialized both servos");
  if (trySTA()) {
    server.on("/status", handleStatus);
    server.on("/feed", HTTP_POST, handleFeed);
    server.on("/factory_reset", HTTP_POST, handleFactoryReset);
    server.begin();
    Serial.println("[HTTP] Server started");
  } else {
    Serial.println("[Setup] No Wi-Fi credentials. Entering provisioning/forwarding mode...");
  }
}

void checkForSerialCreds() {
    if (SerialMaster.available() > 0) {
      String ssid = SerialMaster.readStringUntil('\n');
      String pass = SerialMaster.readStringUntil('\n');
      String customName = SerialMaster.readStringUntil('\n');
      String uid = SerialMaster.readStringUntil('\n');
      ssid.trim();
      pass.trim();
      customName.trim();
      uid.trim();
      if (ssid.length() > 0 && customName.length() > 0 && uid.length() > 0) {
        Serial.println("[Serial] Received info from master:");
        Serial.printf("  ssid=%s\n", ssid.c_str());
        Serial.printf("  customName=%s\n", customName.c_str());
        Serial.printf("  uid=%s\n", uid.c_str());

        saveCreds(ssid, pass, customName, uid);
      }
    }
}

void forwardCredsAndListenForAck() {
  prefs.begin(NVS_NS, true);
  bool fwdComplete = prefs.getBool("fwd_complete", true);
  String ssid = prefs.getString("wifi_ssid", "");
  String pass = prefs.getString("wifi_pass", "");
  String host = prefs.getString("hostname", "");
  String uid = prefs.getString("uid", "");
  prefs.end();
  if (ssid.length() == 0 || uid.length() == 0 || fwdComplete) {
    return;
  }

  if (millis() - lastFwdAttempt < FWD_INTERVAL_MS) {
    return;
  }

  Serial.println("[FWD] Attempting to forward credentials to Feeder 2 CAM...");
  String customName = host.substring(host.lastIndexOf('-') + 1);
  String hostFeeder2 = "pawfeeds-cam-" + customName + "-2";
  SerialFeeder2.printf("%s\n%s\n%s\n%s\n", ssid.c_str(), pass.c_str(), hostFeeder2.c_str(), uid.c_str());
  lastFwdAttempt = millis();
  unsigned long ackWaitStart = millis();
  bool ackReceived = false;
  while (millis() - ackWaitStart < 2000) {
    if (SerialFeeder2.available()) {
      String ack = SerialFeeder2.readStringUntil('\n');
      ack.trim();
      if (ack == "OK") {
        ackReceived = true;
        break;
      }
    }
    delay(50);
  }

  if (ackReceived) {
    Serial.println("[FWD] 'OK' acknowledgment received from Feeder 2 CAM!");
    prefs.begin(NVS_NS, false);
    prefs.putBool("fwd_complete", true);
    prefs.end();
    Serial.println("[FWD] Forwarding complete. Rebooting to connect to Wi-Fi...");
    delay(500);
    ESP.restart();
  } else {
    Serial.println("[FWD] No acknowledgment received. Will retry...");
  }
}

// --- Restored original updateDispense() function ---
void updateDispense() {
  for (int i = 0; i < 2; i++) {
    if (isDispensing[i]) {
      if (millis() - dispenseStartTime[i] >= dispenseDuration[i]) {
        if (i == 0) {
          foodServo1.write(SERVO_STOP_ANGLE);
        } else {
          foodServo2.write(SERVO_STOP_ANGLE);
        }
        isDispensing[i] = false;
        Serial.printf("[SERVO] Dispense complete for feeder %d\n", i + 1);
      }
    }
  }
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    server.handleClient();
    updateDispense(); // This function is needed again for time-based dispensing
  } else {
    checkForSerialCreds();
    forwardCredsAndListenForAck();
  }
  delay(10);
=======
/*
  PawfeedsStd_Slave.ino - FINAL CLOUD-ENABLED & CONTAINER WEIGHT MONITORING
  - Connects to Wi-Fi.
  - On first connection, calls a Cloud Function to register itself in Firestore.
  - Dispenses food based on a timer (original method).
  - Uses an HX711 load cell to monitor the weight of the main food container.
*/
#include <WiFi.h>
#include <Preferences.h>
#include <WebServer.h>
#include <ESP32Servo.h>
#include <HardwareSerial.h>
#include <HTTPClient.h>
#include "HX711.h"

// =================================================================
// HX711 Weight Sensor Configuration (for Container Monitoring)
// =================================================================
// GPIO pins for the HX711
const int LOADCELL_DOUT_PIN = 25; // DT pin
const int LOADCELL_SCK_PIN = 18;  // SCK pin

HX711 scale;

// IMPORTANT: This calibration factor is unique to your load cell.
// You MUST calibrate your sensor to get accurate readings.
float calibration_factor = -7050.0; // Placeholder value, adjust this!

// =================================================================
// Original Hardware & Network Configuration
// =================================================================
HardwareSerial SerialMaster(2); // RX2: 16, TX2: 17
HardwareSerial SerialFeeder2(1); // RX1: 21, TX1: 22

Servo foodServo1;
Servo foodServo2;
static const int SERVO_PIN_1 = 14;
static const int SERVO_PIN_2 = 15;
static const int SERVO_STOP_ANGLE = 90;
static const int SERVO_RUN_ANGLE = 0;

// --- Restored Time-Based Dispensing Variables ---
static const int MS_PER_GRAM = 77;
static const int OFFSET_MS = -350;
bool isDispensing[2] = {false, false};
unsigned long dispenseStartTime[2] = {0, 0};
unsigned long dispenseDuration[2] = {0, 0};

unsigned long lastFwdAttempt = 0;
const unsigned long FWD_INTERVAL_MS = 5000;

Preferences prefs;
WebServer server(80);
static const char* NVS_NS = "pawfeeds";
static const uint8_t MAX_CONNECT_SECONDS = 30;
// --- IMPORTANT: Paste your Cloud Function URL here ---
const char* cloudFunctionUrl = "https://registerdevice-cy5wm3auoq-df.a.run.app";

String ipToStr(IPAddress ip) {
  return String(ip[0]) + "." + ip[1] + "." + ip[2] + "." + ip[3];
}

void handleStatus() {
  String ip = (WiFi.isConnected()) ? ipToStr(WiFi.localIP()) : "";
  String hostname = WiFi.getHostname() ? String(WiFi.getHostname()) : "";
  
  // Read current container weight from the sensor
  float container_weight = scale.get_units(5); // Get an average of 5 readings
  
  String body = String("{\"mode\":\"sta\",\"connected\":") + (WiFi.isConnected() ? "true" : "false") +
                ",\"ip\":\"" + ip +
                "\",\"hostname\":\"" + hostname + 
                "\",\"container_weight_grams\":" + String(container_weight) + "}";
  server.send(200, "application/json", body);
}

// --- Restored Original Time-Based handleFeed function ---
void handleFeed() {
  if (!server.hasArg("plain")) {
    server.send(400, "application/json", "{\"error\":\"missing_body\"}");
    return;
  }
  String body = server.arg("plain");
  String keyGrams = "\"grams\":";
  int keyIndexGrams = body.indexOf(keyGrams);
  int grams = 0;
  if (keyIndexGrams != -1) {
    int valueIndex = keyIndexGrams + keyGrams.length();
    grams = body.substring(valueIndex).toInt();
  }

  String keyFeeder = "\"feeder\":";
  int keyIndexFeeder = body.indexOf(keyFeeder);
  int feederId = 1;
  if (keyIndexFeeder != -1) {
    int valueIndex = keyIndexFeeder + keyFeeder.length();
    feederId = body.substring(valueIndex).toInt();
  }
  
  int feederIndex = (feederId == 2) ? 1 : 0;
  if (isDispensing[feederIndex]) {
    server.send(409, "application/json", "{\"status\":\"busy\", \"feeder\":" + String(feederId) + "}");
    return;
  }
  
  if (grams <= 0) {
    server.send(400, "application/json", "{\"error\":\"invalid_grams\", \"received_body\":\"" + body + "\"}");
    return;
  }
  
  isDispensing[feederIndex] = true;
  long calculatedDuration = ((long)grams * MS_PER_GRAM) + OFFSET_MS;
  dispenseDuration[feederIndex] = (calculatedDuration > 0) ? calculatedDuration : 0;
  dispenseStartTime[feederIndex] = millis();
  if (feederIndex == 0) {
    foodServo1.write(SERVO_RUN_ANGLE);
  } else {
    foodServo2.write(SERVO_RUN_ANGLE);
  }
  
  Serial.printf("[/feed] Dispensing %d grams from feeder %d for %lu ms\n", grams, feederId, dispenseDuration[feederIndex]);
  server.send(202, "application/json", "{\"status\":\"started\", \"grams\":" + String(grams) + ", \"feeder\":" + String(feederId) + "}");
}


void eraseCreds() {
  prefs.begin(NVS_NS, false);
  prefs.remove("wifi_ssid");
  prefs.remove("wifi_pass");
  prefs.remove("hostname");
  prefs.remove("fwd_complete");
  prefs.remove("uid");
  prefs.remove("registered");
  prefs.end();
  Serial.println("[NVS] Cleared credentials, UID, forwarding flag, and registered flag.");
}

void handleFactoryReset() {
  eraseCreds();
  server.send(200, "application/json", "{\"ok\":true,\"reset\":true}");
  Serial.println("[/factory_reset] Reset + reboot");
  delay(250);
  ESP.restart();
}

void saveCreds(const String& ssid, const String& pass, const String& customName, const String& uid) {
  prefs.begin(NVS_NS, false);
  prefs.putString("wifi_ssid", ssid);
  prefs.putString("wifi_pass", pass);
  String finalHost = "pawfeeds-std-" + customName;
  prefs.putString("hostname", finalHost);
  prefs.putString("uid", uid);
  prefs.putBool("fwd_complete", false);
  prefs.putBool("registered", false);
  prefs.end();
  Serial.println("[NVS] Saved credentials for Standard Feeder. Forwarding/Registered flags set to false.");
  Serial.printf("  -> Hostname: %s\n", finalHost.c_str());
  Serial.printf("  -> UID: %s\n", uid.c_str());
}

void registerDeviceInCloud() {
  prefs.begin(NVS_NS, true);
  bool isRegistered = prefs.getBool("registered", false);
  String uid = prefs.getString("uid", "");
  String hostname = prefs.getString("hostname", "");
  prefs.end();
  if (isRegistered || uid.length() == 0 || hostname.length() == 0) {
    return;
  }

  Serial.println("[Cloud] Device not registered. Attempting to register now...");

  HTTPClient http;
  http.begin(cloudFunctionUrl);
  http.addHeader("Content-Type", "application/json");

  String deviceId = WiFi.macAddress();
  deviceId.replace(":", "");
  String payload = "{\"data\":{\"uid\":\"" + uid + "\",\"deviceId\":\"" + deviceId + "\",\"name\":\"" + hostname + "\"}}";
  int httpCode = http.POST(payload);

  if (httpCode > 0) {
    String response = http.getString();
    Serial.printf("[Cloud] Registration response code: %d\n", httpCode);
    Serial.println("[Cloud] Response: " + response);
    if (httpCode == 200) {
      Serial.println("[Cloud] Registration successful! Setting flag.");
      prefs.begin(NVS_NS, false);
      prefs.putBool("registered", true);
      prefs.end();
    }
  } else {
    Serial.printf("[Cloud] Registration failed, error: %s\n", http.errorToString(httpCode).c_str());
  }
  http.end();
}

bool trySTA() {
  prefs.begin(NVS_NS, true);
  String ssid = prefs.getString("wifi_ssid", "");
  String pass = prefs.getString("wifi_pass", "");
  String host = prefs.getString("hostname", "");
  prefs.end();
  if (ssid.length() == 0) return false;

  Serial.println("[STA] Trying to connect with saved credentials...");
  WiFi.mode(WIFI_STA);
  if (host.length()) WiFi.setHostname(host.c_str());
  WiFi.begin(ssid.c_str(), pass.c_str());
  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && (millis() - t0) < (MAX_CONNECT_SECONDS * 1000UL)) {
    delay(300);
    Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("[STA] Connected. IP=%s Hostname=%s\n", WiFi.localIP().toString().c_str(), WiFi.getHostname() ? WiFi.getHostname() : "(none)");
    registerDeviceInCloud();
    return true;
  }
  Serial.printf("[STA] Failed, status=%d\n", WiFi.status());
  return false;
}

void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\n=== PawfeedsStd SLAVE/FORWARDER Boot (Container Weight Monitoring) ===");

  SerialMaster.begin(9600, SERIAL_8N1, 16, 17);
  SerialFeeder2.begin(9600, SERIAL_8N1, 21, 22);
  Serial.println("[Serial] Initialized Serial1(RX:21,TX:22) and Serial2(RX:16,TX:17).");
  
  // --- HX711 Initialization ---
  Serial.println("[HX711] Initializing scale for container monitoring...");
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
  scale.set_scale(calibration_factor);
  scale.tare(10); // Tare the scale on boot-up. Assumes container is empty at this point.
  Serial.println("[HX711] Scale initialized and tared.");
  Serial.printf("[HX711] Initial container reading: %.2fg\n", scale.get_units(5));

  ESP32PWM::allocateTimer(0);
  foodServo1.setPeriodHertz(50);
  foodServo1.attach(SERVO_PIN_1, 500, 2400);
  foodServo1.write(SERVO_STOP_ANGLE);

  ESP32PWM::allocateTimer(1);
  foodServo2.setPeriodHertz(50);
  foodServo2.attach(SERVO_PIN_2, 500, 2400);
  foodServo2.write(SERVO_STOP_ANGLE);
  Serial.println("[SERVO] Initialized both servos");
  if (trySTA()) {
    server.on("/status", handleStatus);
    server.on("/feed", HTTP_POST, handleFeed);
    server.on("/factory_reset", HTTP_POST, handleFactoryReset);
    server.begin();
    Serial.println("[HTTP] Server started");
  } else {
    Serial.println("[Setup] No Wi-Fi credentials. Entering provisioning/forwarding mode...");
  }
}

void checkForSerialCreds() {
    if (SerialMaster.available() > 0) {
      String ssid = SerialMaster.readStringUntil('\n');
      String pass = SerialMaster.readStringUntil('\n');
      String customName = SerialMaster.readStringUntil('\n');
      String uid = SerialMaster.readStringUntil('\n');
      ssid.trim();
      pass.trim();
      customName.trim();
      uid.trim();
      if (ssid.length() > 0 && customName.length() > 0 && uid.length() > 0) {
        Serial.println("[Serial] Received info from master:");
        Serial.printf("  ssid=%s\n", ssid.c_str());
        Serial.printf("  customName=%s\n", customName.c_str());
        Serial.printf("  uid=%s\n", uid.c_str());

        saveCreds(ssid, pass, customName, uid);
      }
    }
}

void forwardCredsAndListenForAck() {
  prefs.begin(NVS_NS, true);
  bool fwdComplete = prefs.getBool("fwd_complete", true);
  String ssid = prefs.getString("wifi_ssid", "");
  String pass = prefs.getString("wifi_pass", "");
  String host = prefs.getString("hostname", "");
  String uid = prefs.getString("uid", "");
  prefs.end();
  if (ssid.length() == 0 || uid.length() == 0 || fwdComplete) {
    return;
  }

  if (millis() - lastFwdAttempt < FWD_INTERVAL_MS) {
    return;
  }

  Serial.println("[FWD] Attempting to forward credentials to Feeder 2 CAM...");
  String customName = host.substring(host.lastIndexOf('-') + 1);
  String hostFeeder2 = "pawfeeds-cam-" + customName + "-2";
  SerialFeeder2.printf("%s\n%s\n%s\n%s\n", ssid.c_str(), pass.c_str(), hostFeeder2.c_str(), uid.c_str());
  lastFwdAttempt = millis();
  unsigned long ackWaitStart = millis();
  bool ackReceived = false;
  while (millis() - ackWaitStart < 2000) {
    if (SerialFeeder2.available()) {
      String ack = SerialFeeder2.readStringUntil('\n');
      ack.trim();
      if (ack == "OK") {
        ackReceived = true;
        break;
      }
    }
    delay(50);
  }

  if (ackReceived) {
    Serial.println("[FWD] 'OK' acknowledgment received from Feeder 2 CAM!");
    prefs.begin(NVS_NS, false);
    prefs.putBool("fwd_complete", true);
    prefs.end();
    Serial.println("[FWD] Forwarding complete. Rebooting to connect to Wi-Fi...");
    delay(500);
    ESP.restart();
  } else {
    Serial.println("[FWD] No acknowledgment received. Will retry...");
  }
}

// --- Restored original updateDispense() function ---
void updateDispense() {
  for (int i = 0; i < 2; i++) {
    if (isDispensing[i]) {
      if (millis() - dispenseStartTime[i] >= dispenseDuration[i]) {
        if (i == 0) {
          foodServo1.write(SERVO_STOP_ANGLE);
        } else {
          foodServo2.write(SERVO_STOP_ANGLE);
        }
        isDispensing[i] = false;
        Serial.printf("[SERVO] Dispense complete for feeder %d\n", i + 1);
      }
    }
  }
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    server.handleClient();
    updateDispense(); // This function is needed again for time-based dispensing
  } else {
    checkForSerialCreds();
    forwardCredsAndListenForAck();
  }
  delay(10);
>>>>>>> c44f57a (Initial commit without bin and obj)
}